#include <stdio.h>
#include <stdlib.h>
#include <pjlib.h>
#include <pjlib-util.h>
#include <pjnath.h>
#include <gst/gst.h>
#include <assert.h>
#include "pjnath_initialize.h"
#include "login.h"
#include "gstpjnath.h"
#include "core.h"
#include <unistd.h>

#define STUN_SERVER_ADDRESS "107.23.150.92"
#define STUN_SERVER_PORT 3478
#define ICE_INFOR_SIZE 1000
#define MAX_TAG 20
#define MAX_TAG_LENGTH 50
#define THIS_FILE   "pjnath_initialize.c"

/* For this demo app, configure longer STUN keep-alive time
 * so that it does't clutter the screen output.
 */
#define KA_INTERVAL 300

char *peerIdRpi;
char *androidMasterId;
char *androidClientId;

/* Utility to display error messages */
static void
holder_perror (const char *title, pj_status_t status)
{
  char errmsg[PJ_ERR_MSG_SIZE];

  pj_strerror (status, errmsg, sizeof (errmsg));
  PJ_LOG (1, (THIS_FILE, "%s: %s", title, errmsg));
}

/* Utility: display error message and exit application (usually
 * because of fatal error.
 */
static void
err_exit (const char *title, pj_status_t status, PjnathHolder * holder)
{
  if (status != PJ_SUCCESS) {
    holder_perror (title, status);
  }
  PJ_LOG (3, (THIS_FILE, "Shutting down.."));

  if (holder->icest)
    pj_ice_strans_destroy (holder->icest);

  pj_thread_sleep (500);

  holder->thread_quit_flag = PJ_TRUE;
  if (holder->thread) {
    pj_thread_join (holder->thread);
    pj_thread_destroy (holder->thread);
  }

  if (holder->ice_cfg.stun_cfg.ioqueue)
    pj_ioqueue_destroy (holder->ice_cfg.stun_cfg.ioqueue);

  if (holder->ice_cfg.stun_cfg.timer_heap)
    pj_timer_heap_destroy (holder->ice_cfg.stun_cfg.timer_heap);

  pj_caching_pool_destroy (&holder->cp);

  pj_shutdown ();

  if (holder->log_fhnd) {
    fclose (holder->log_fhnd);
    holder->log_fhnd = NULL;
  }

  exit (status != PJ_SUCCESS);
}

#define CHECK(expr)	status=expr; \
if (status!=PJ_SUCCESS) { \
err_exit(#expr, status, holder); \
}

/*
 * This function checks for events from both timer and ioqueue (for
 * network events). It is invoked by the worker thread.
 */
static pj_status_t
handle_events (unsigned max_msec, unsigned *p_count, PjnathHolder * holder)
{
  enum
  { MAX_NET_EVENTS = 1 };
  pj_time_val max_timeout = { 0, 0 };
  pj_time_val timeout = { 0, 0 };
  unsigned count = 0, net_event_count = 0;
  int c;

  max_timeout.msec = max_msec;

  /* Poll the timer to run it and also to retrieve the earliest entry. */
  timeout.sec = timeout.msec = 0;
  c = pj_timer_heap_poll (holder->ice_cfg.stun_cfg.timer_heap, &timeout);
  if (c > 0)
    count += c;

  /* timer_heap_poll should never ever returns negative value, or otherwise
   * ioqueue_poll() will block forever!
   */
  //pj_assert(timeout.sec >= 0 && timeout.msec >= 0);
  if (timeout.msec >= ICE_INFOR_SIZE)
    timeout.msec = 999;

  /* compare the value with the timeout to wait from timer, and use the
   * minimum value.
   */
  if (PJ_TIME_VAL_GT (timeout, max_timeout))
    timeout = max_timeout;

  /* Poll ioqueue.
   * Repeat polling the ioqueue while we have immediate events, because
   * timer heap may process more than one events, so if we only process
   * one network events at a time (such as when IOCP backend is used),
   * the ioqueue may have trouble keeping up with the request rate.
   *
   * For example, for each send() request, one network event will be
   *   reported by ioqueue for the send() completion. If we don't poll
   *   the ioqueue often enough, the send() completion will not be
   *   reported in timely manner.
   */
  do {
    c = pj_ioqueue_poll (holder->ice_cfg.stun_cfg.ioqueue, &timeout);
    if (c < 0) {
      pj_status_t err = pj_get_netos_error ();
      pj_thread_sleep (PJ_TIME_VAL_MSEC (timeout));
      if (p_count)
        *p_count = count;
      return err;
    } else if (c == 0) {
      break;
    } else {
      net_event_count += c;
      timeout.sec = timeout.msec = 0;
    }
  } while (c > 0 && net_event_count < MAX_NET_EVENTS);

  count += net_event_count;
  if (p_count)
    *p_count = count;

  return PJ_SUCCESS;

}

/*
 * This is the worker thread that polls event in the background.
 */
static int
holder_worker_thread (PjnathHolder * holder)
{
  //PJ_UNUSED_ARG(unused);
  printf ("\nholder_worker_thread\n");
  while (!holder->thread_quit_flag) {
    handle_events (500, NULL, holder);
  }

  return 0;
}

/*
 * This is the callback that is registered to the ICE stream transport to
 * receive notification about incoming data. By "data" it means application
 * data such as RTP/RTCP, and not packets that belong to ICE signaling (such
 * as STUN connectivity checks or TURN signaling).
 */
static void
cb_on_rx_data (pj_ice_strans * ice_st,
    unsigned comp_id,
    void *pkt, pj_size_t size,
    const pj_sockaddr_t * src_addr, unsigned src_addr_len)
{
  //__android_log_print(ANDROID_LOG_DEBUG, __FILE__, "cb_on_rx_data");
  char ipstr[PJ_INET6_ADDRSTRLEN + 10];

  PJ_UNUSED_ARG (ice_st);
  PJ_UNUSED_ARG (src_addr_len);
  PJ_UNUSED_ARG (pkt);

  // Don't do this! It will ruin the packet buffer in case TCP is used!
  //((char*)pkt)[size] = '\0';

  PJ_LOG (3, (THIS_FILE,
          "\x1b[31mComponent %d: received %d bytes data from %s: \"%.*s\"\x1b[0m",
          comp_id, size, pj_sockaddr_print (src_addr, ipstr, sizeof (ipstr), 3),
          (unsigned) size, (char *) pkt));
}

/*
 * This is the callback that is registered to the ICE stream transport to
 * receive notification about ICE state progression.
 */
static void
cb_on_ice_complete (pj_ice_strans * ice_st,
    pj_ice_strans_op op, pj_status_t status)
{
  const char *opname =
      (op == PJ_ICE_STRANS_OP_INIT ? "initialization" :
      (op == PJ_ICE_STRANS_OP_NEGOTIATION ? "negotiation" : "unknown_op"));

  if (status == PJ_SUCCESS) {
    PJ_LOG (3, (THIS_FILE, "ICE %s successful", opname));
    printf ("cb_on_ice_complete successful");
  } else {
    char errmsg[PJ_ERR_MSG_SIZE];

    pj_strerror (status, errmsg, sizeof (errmsg));
    PJ_LOG (1, (THIS_FILE, "ICE %s failed: %s", opname, errmsg));
    pj_ice_strans_destroy (ice_st);
    //holder->icest = NULL;
  }

  // holder->ice_complete = 1;
}

/* log callback to write to file */
static void
log_func (int level, const char *data, int len, PjnathHolder * holder)
{
  pj_log_write (level, data, len);
  if (holder->log_fhnd) {
    if (fwrite (data, len, 1, holder->log_fhnd) != 1)
      return;
  }
}

/*
 * This is the main application initialization function. It is called
 * once (and only once) during application initialization sequence by
 * main().
 */
static pj_status_t
holder_init (PjnathHolder * holder)
{
  printf ("holder_init");
  pj_status_t status;

  holder->opt.comp_cnt = 1;
  holder->opt.max_host = -1;

  if (holder->opt.log_file) {
    holder->log_fhnd = fopen (holder->opt.log_file, "a");
    pj_log_set_log_func (&log_func);
  }

  /* Initialize the libraries before anything else */
  CHECK (pj_init ());
  CHECK (pjlib_util_init ());
  CHECK (pjnath_init ());

  /* Must create pool factory, where memory allocations come from */
  pj_caching_pool_init (&holder->cp, NULL, 0);

  /* Init our ICE settings with null values */
  pj_ice_strans_cfg_default (&holder->ice_cfg);
  holder->ice_cfg.stun_cfg.pf = &holder->cp.factory;

  /* Create application memory pool */
  holder->pool = pj_pool_create (&holder->cp.factory, "holder", 512, 512, NULL);
  /* Create timer heap for timer stuff */
  CHECK (pj_timer_heap_create (holder->pool, 100,
          &holder->ice_cfg.stun_cfg.timer_heap));
  /* and create ioqueue for network I/O stuff */
  CHECK (pj_ioqueue_create (holder->pool, 16,
          &holder->ice_cfg.stun_cfg.ioqueue));
  /* something must poll the timer heap and ioqueue,
   * unless we're on Symbian where the timer heap and ioqueue run
   * on themselves.
   */
  CHECK (pj_thread_create (holder->pool, "holder", &holder_worker_thread,
          (void *) holder, 0, 0, &holder->thread));
  holder->ice_cfg.af = pj_AF_INET ();

  /* Create DNS resolver if nameserver is set */
  if (holder->opt.ns.slen) {
    CHECK (pj_dns_resolver_create (&holder->cp.factory,
            "resolver",
            0,
            holder->ice_cfg.stun_cfg.timer_heap,
            holder->ice_cfg.stun_cfg.ioqueue, &holder->ice_cfg.resolver));

    CHECK (pj_dns_resolver_set_ns (holder->ice_cfg.resolver, 1,
            &holder->opt.ns, NULL));
  }
  /* -= Start initializing ICE stream transport config =- */

  /* Maximum number of host candidates */
  if (holder->opt.max_host != -1)
    holder->ice_cfg.stun.max_host_cands = holder->opt.max_host;

  /* Nomination strategy */
  if (holder->opt.regular)
    holder->ice_cfg.opt.aggressive = PJ_FALSE;
  else
    holder->ice_cfg.opt.aggressive = PJ_TRUE;

  /* Configure STUN/srflx candidate resolution */
  holder->opt.stun_srv.ptr = (char *) calloc (100, sizeof (char));
  strncpy (holder->opt.stun_srv.ptr, "107.23.150.92:3478",
      strlen ("107.23.150.92:3478"));
  holder->opt.stun_srv.slen = strlen (holder->opt.stun_srv.ptr);

  if (holder->opt.stun_srv.slen) {
    char *pos;

    /* Command line option may contain port number */
    if ((pos = pj_strchr (&holder->opt.stun_srv, ':')) != NULL) {
      holder->ice_cfg.stun.server.ptr = holder->opt.stun_srv.ptr;
      holder->ice_cfg.stun.server.slen = (pos - holder->opt.stun_srv.ptr);

      holder->ice_cfg.stun.port = (pj_uint16_t) atoi (pos + 1);
    } else {
      holder->ice_cfg.stun.server = holder->opt.stun_srv;
      holder->ice_cfg.stun.port = PJ_STUN_PORT;
    }

    /* For this demo app, configure longer STUN keep-alive time
     * so that it does't clutter the screen output.
     */
    holder->ice_cfg.stun.cfg.ka_interval = KA_INTERVAL;
  }

  /* Configure TURN candidate */
  if (holder->opt.turn_srv.slen) {
    char *pos;

    /* Command line option may contain port number */
    if ((pos = pj_strchr (&holder->opt.turn_srv, ':')) != NULL) {
      holder->ice_cfg.turn.server.ptr = holder->opt.turn_srv.ptr;
      holder->ice_cfg.turn.server.slen = (pos - holder->opt.turn_srv.ptr);

      holder->ice_cfg.turn.port = (pj_uint16_t) atoi (pos + 1);
    } else {
      holder->ice_cfg.turn.server = holder->opt.turn_srv;
      holder->ice_cfg.turn.port = PJ_STUN_PORT;
    }

    /* TURN credential */
    holder->ice_cfg.turn.auth_cred.type = PJ_STUN_AUTH_CRED_STATIC;
    holder->ice_cfg.turn.auth_cred.data.static_cred.username =
        holder->opt.turn_username;
    holder->ice_cfg.turn.auth_cred.data.static_cred.data_type =
        PJ_STUN_PASSWD_PLAIN;
    holder->ice_cfg.turn.auth_cred.data.static_cred.data =
        holder->opt.turn_password;

    /* Connection type to TURN server */
    if (holder->opt.turn_tcp)
      holder->ice_cfg.turn.conn_type = PJ_TURN_TP_TCP;
    else
      holder->ice_cfg.turn.conn_type = PJ_TURN_TP_UDP;

    /* For this demo app, configure longer keep-alive time
     * so that it does't clutter the screen output.
     */
    holder->ice_cfg.turn.alloc_param.ka_interval = KA_INTERVAL;
  }

  /* -= That's it for now, initialization is complete =- */
  return PJ_SUCCESS;
}


/*
 * Create ICE stream transport instance, invoked from the menu.
 */
static void
holder_create_instance (PjnathHolder * holder)
{
  printf ("holder_create_instance");
  pj_ice_strans_cb icecb;
  pj_status_t status;

  if (holder->icest != NULL) {
    printf ("ICE instance already created, destroy it first");
    return;
  }

  /* init the callback */
  pj_bzero (&icecb, sizeof (icecb));

  icecb.on_rx_data = gst_cb_on_rx_data;
  icecb.on_ice_complete = cb_on_ice_complete;

  printf ("%d, %d, %d", holder->opt.comp_cnt, &icecb, &holder->icest);

  /* create the instance */
  status = pj_ice_strans_create ("holder",      /* object name  */
      &holder->ice_cfg,         /* settings     */
      holder->opt.comp_cnt,     /* comp_cnt     */
      NULL,                     /* user data    */
      &icecb,                   /* callback     */
      &holder->icest);          /* instance ptr */

  if (status != PJ_SUCCESS)
    printf ("error creating ice");
  else
    PJ_LOG (3, (THIS_FILE, "ICE instance successfully created"));
}

/* Utility to nullify parsed remote info */
static void
reset_rem_info (PjnathHolder * holder)
{
  pj_bzero (&holder->rem, sizeof (holder->rem));
}


/*
 * Destroy ICE stream transport instance, invoked from the menu.
 */
static void
holder_destroy_instance (PjnathHolder * holder)
{
  if (holder->icest == NULL) {
    PJ_LOG (1, (THIS_FILE, "Error: No ICE instance, create it first"));
    return;
  }

  pj_ice_strans_destroy (holder->icest);
  holder->icest = NULL;

  reset_rem_info (holder);

  PJ_LOG (3, (THIS_FILE, "ICE instance destroyed"));
}


/*
 * Create ICE session, invoked from the menu.
 */
static void
holder_init_session (unsigned rolechar, PjnathHolder * holder)
{
  printf ("holder_init_session");
  pj_ice_sess_role role = (pj_tolower ((pj_uint8_t) rolechar) == 'o' ?
      PJ_ICE_SESS_ROLE_CONTROLLING : PJ_ICE_SESS_ROLE_CONTROLLED);
  pj_status_t status;

  if (holder->icest == NULL) {
    PJ_LOG (1, (THIS_FILE, "Error: No ICE instance, create it first"));
    return;
  }

  if (pj_ice_strans_has_sess (holder->icest)) {
    PJ_LOG (1, (THIS_FILE, "Error: Session already created"));
    return;
  }

  status = pj_ice_strans_init_ice (holder->icest, role, NULL, NULL);
  if (status != PJ_SUCCESS)
    holder_perror ("error creating session", status);
  else
    PJ_LOG (3, (THIS_FILE, "ICE session created"));

  reset_rem_info (holder);
}


/*
 * Stop/destroy ICE session, invoked from the menu.
 */
static void
holder_stop_session (PjnathHolder * holder)
{
  pj_status_t status;

  if (holder->icest == NULL) {
    PJ_LOG (1, (THIS_FILE, "Error: No ICE instance, create it first"));
    return;
  }

  if (!pj_ice_strans_has_sess (holder->icest)) {
    PJ_LOG (1, (THIS_FILE, "Error: No ICE session, initialize first"));
    return;
  }

  status = pj_ice_strans_stop_ice (holder->icest);
  if (status != PJ_SUCCESS)
    holder_perror ("error stopping session", status);
  else
    PJ_LOG (3, (THIS_FILE, "ICE session stopped"));

  reset_rem_info (holder);
}

#define PRINT(fmt, arg0, arg1, arg2, arg3, arg4, arg5)	    \
printed = pj_ansi_snprintf(p, maxlen - (p-buffer),  \
fmt, arg0, arg1, arg2, arg3, arg4, arg5); \
if (printed <= 0) return -PJ_ETOOSMALL; \
p += printed


/* Utility to create a=candidate SDP attribute */
static int
print_cand (char buffer[], unsigned maxlen, const pj_ice_sess_cand * cand)
{
  char ipaddr[PJ_INET6_ADDRSTRLEN];
  char *p = buffer;
  int printed;

  PRINT ("a=candidate:%.*s %u UDP %u %s %u typ ",
      (int) cand->foundation.slen,
      cand->foundation.ptr,
      (unsigned) cand->comp_id,
      cand->prio,
      pj_sockaddr_print (&cand->addr, ipaddr,
          sizeof (ipaddr), 0), (unsigned) pj_sockaddr_get_port (&cand->addr));

  PRINT ("%s\n", pj_ice_get_cand_type_name (cand->type), 0, 0, 0, 0, 0);

  if (p == buffer + maxlen)
    return -PJ_ETOOSMALL;

  *p = '\0';

  return p - buffer;
}

/*
 * Encode ICE information in SDP.
 */
static int
encode_session (char buffer[], unsigned maxlen, PjnathHolder * holder)
{
  char *p = buffer;
  unsigned comp;
  int printed;
  pj_str_t local_ufrag, local_pwd;
  pj_status_t status;

  /* Write "dummy" SDP v=, o=, s=, and t= lines */
  PRINT ("v=0\no=- 3414953978 3414953978 IN IP4 localhost\ns=ice\nt=0 0\n",
      0, 0, 0, 0, 0, 0);

  /* Get ufrag and pwd from current session */
  pj_ice_strans_get_ufrag_pwd (holder->icest, &local_ufrag, &local_pwd,
      NULL, NULL);

  /* Write the a=ice-ufrag and a=ice-pwd attributes */
  PRINT ("a=ice-ufrag:%.*s\na=ice-pwd:%.*s\n",
      (int) local_ufrag.slen,
      local_ufrag.ptr, (int) local_pwd.slen, local_pwd.ptr, 0, 0);
  /* Write each component */
  for (comp = 0; comp < holder->opt.comp_cnt; ++comp) {
    unsigned j, cand_cnt;
    pj_ice_sess_cand cand[PJ_ICE_ST_MAX_CAND];
    char ipaddr[PJ_INET6_ADDRSTRLEN];

    /* Get default candidate for the component */
    status = pj_ice_strans_get_def_cand (holder->icest, comp + 1, &cand[0]);
    if (status != PJ_SUCCESS)
      return -status;

    /* Write the default address */
    if (comp == 0) {
      /* For component 1, default address is in m= and c= lines */
      PRINT ("m=audio %d RTP/AVP 0\n"
          "c=IN IP4 %s\n",
          (int) pj_sockaddr_get_port (&cand[0].addr),
          pj_sockaddr_print (&cand[0].addr, ipaddr,
              sizeof (ipaddr), 0), 0, 0, 0, 0);
    } else if (comp == 1) {
      /* For component 2, default address is in a=rtcp line */
      PRINT ("a=rtcp:%d IN IP4 %s\n",
          (int) pj_sockaddr_get_port (&cand[0].addr),
          pj_sockaddr_print (&cand[0].addr, ipaddr,
              sizeof (ipaddr), 0), 0, 0, 0, 0);
    } else {
      /* For other components, we'll just invent this.. */
      PRINT ("a=Xice-defcand:%d IN IP4 %s\n",
          (int) pj_sockaddr_get_port (&cand[0].addr),
          pj_sockaddr_print (&cand[0].addr, ipaddr,
              sizeof (ipaddr), 0), 0, 0, 0, 0);
    }

    /* Enumerate all candidates for this component */
    cand_cnt = PJ_ARRAY_SIZE (cand);
    status = pj_ice_strans_enum_cands (holder->icest, comp + 1,
        &cand_cnt, cand);
    if (status != PJ_SUCCESS)
      return -status;

    /* And encode the candidates as SDP */
    for (j = 0; j < cand_cnt; ++j) {
      printed = print_cand (p, maxlen - (p - buffer), &cand[j]);
      if (printed < 0)
        return -PJ_ETOOSMALL;
      p += printed;
    }
  }

  if (p == buffer + maxlen)
    return -PJ_ETOOSMALL;

  *p = '\0';
  return p - buffer;
}


/*
 * Show information contained in the ICE stream transport. This is
 * invoked from the menu.
 */
static void
holder_show_ice (PjnathHolder * holder)
{
  printf ("holder_show_ice");
  static char buffer[ICE_INFOR_SIZE];
  int len;
  holder->local_info = (char *) malloc (ICE_INFOR_SIZE);
  memset (holder->local_info, '\0', ICE_INFOR_SIZE);

  if (holder->icest == NULL) {
    PJ_LOG (1, (THIS_FILE, "Error: No ICE instance, create it first"));
    return;
  }

  puts ("General info");
  puts ("---------------");
  printf ("Component count    : %d\n", holder->opt.comp_cnt);
  printf ("Status             : ");
  if (pj_ice_strans_sess_is_complete (holder->icest))
    puts ("negotiation complete");
  else if (pj_ice_strans_sess_is_running (holder->icest))
    puts ("negotiation is in progress");
  else if (pj_ice_strans_has_sess (holder->icest))
    puts ("session ready");
  else
    puts ("session not created");

  if (!pj_ice_strans_has_sess (holder->icest)) {
    puts ("Create the session first to see more info");
    return;
  }

  printf ("Negotiated comp_cnt: %d\n",
      pj_ice_strans_get_running_comp_cnt (holder->icest));
  printf ("Role               : %s\n",
      pj_ice_strans_get_role (holder->icest) == PJ_ICE_SESS_ROLE_CONTROLLED ?
      "controlled" : "controlling");

  len = encode_session (buffer, sizeof (buffer), holder);
  if (len < 0)
    err_exit ("not enough buffer to show ICE status", -len, holder);

  strncpy (holder->local_info, buffer, strlen (buffer));

  puts ("");
  printf ("Local SDP (paste this to remote host):\n"
      "--------------------------------------\n" "%s\n", buffer);


  puts ("");
  puts ("Remote info:\n" "----------------------");
  if (holder->rem.cand_cnt == 0) {
    puts ("No remote info yet");
  } else {
    unsigned i;

    printf ("Remote ufrag       : %s\n", holder->rem.ufrag);
    printf ("Remote password    : %s\n", holder->rem.pwd);
    printf ("Remote cand. cnt.  : %d\n", holder->rem.cand_cnt);

    for (i = 0; i < holder->rem.cand_cnt; ++i) {
      len = print_cand (buffer, sizeof (buffer), &holder->rem.cand[i]);
      if (len < 0)
        err_exit ("not enough buffer to show ICE status", -len, holder);

      printf ("  %s", buffer);
    }
  }
}


/*
 * Input and parse SDP from the remote (containing remote's ICE information)
 * and save it to global variables.
 */
static void
holder_input_remote (const char *ice_sdp, PjnathHolder * holder)
{
  printf ("holder_input_remote");
  char linebuf[80];
  unsigned media_cnt = 0;
  unsigned comp0_port = 0;
  char comp0_addr[80];
  pj_bool_t done = PJ_FALSE;
  const char *curLine = ice_sdp;
  char *tempStr;

  puts ("Paste SDP from remote host, end with empty line");

  reset_rem_info (holder);

  comp0_addr[0] = '\0';

  while (!done) {
    int len;
    char *line;

    //      __android_log_print (ANDROID_LOG_DEBUG,
    //                                              THIS_FILE, ">");
    //      if (stdout) fflush(stdout);
    //
    //      if (fgets(linebuf, sizeof(linebuf), stdin)==NULL)
    //          break;

    //while(curLine)
    //{
    const char *nextLine = strchr (curLine, '\n');
    int curLineLen = nextLine ? (nextLine - curLine) : strlen (curLine);
    tempStr = (char *) malloc (curLineLen + 1);
    if (tempStr) {
      memcpy (tempStr, curLine, curLineLen);
      tempStr[curLineLen] = '\0';       // NUL-terminate!
    } else {
      //__android_log_print (ANDROID_LOG_DEBUG,
      //                          THIS_FILE, "malloc() failed!?\n");
    }

    curLine = nextLine ? (nextLine + 1) : NULL;
    //}

    memset (linebuf, '\0', sizeof (linebuf));
    strncpy (linebuf, tempStr, strlen (tempStr));

    len = strlen (linebuf);
    while (len && (linebuf[len - 1] == '\r' || linebuf[len - 1] == '\n'))
      linebuf[--len] = '\0';

    line = linebuf;

    while (len && pj_isspace (*line))
      ++line, --len;

    printf ("line = [%s]\n", line);

    if (len == 0)
      break;

    /* Ignore subsequent media descriptors */
    if (media_cnt > 1)
      continue;

    switch (line[0]) {
      case 'm':
      {
        int cnt;
        char media[32], portstr[32];

        ++media_cnt;
        if (media_cnt > 1) {
          puts ("Media line ignored");
          break;
        }

        cnt = sscanf (line + 2, "%s %s RTP/", media, portstr);
        if (cnt != 2) {
          PJ_LOG (1, (THIS_FILE, "Error parsing media line"));
          goto on_error;
        }

        comp0_port = atoi (portstr);

      }
        break;
      case 'c':
      {
        int cnt;
        char c[32], net[32], ip[80];

        cnt = sscanf (line + 2, "%s %s %s", c, net, ip);
        if (cnt != 3) {
          PJ_LOG (1, (THIS_FILE, "Error parsing connection line"));
          goto on_error;
        }

        strcpy (comp0_addr, ip);
      }
        break;
      case 'a':
      {
        char *attr = strtok (line + 2, ": \t\r\n");
        if (strcmp (attr, "ice-ufrag") == 0) {
          strcpy (holder->rem.ufrag, attr + strlen (attr) + 1);
        } else if (strcmp (attr, "ice-pwd") == 0) {
          strcpy (holder->rem.pwd, attr + strlen (attr) + 1);
        } else if (strcmp (attr, "rtcp") == 0) {
          char *val = attr + strlen (attr) + 1;
          int af, cnt;
          int port;
          char net[32], ip[64];
          pj_str_t tmp_addr;
          pj_status_t status;

          cnt = sscanf (val, "%d IN %s %s", &port, net, ip);
          if (cnt != 3) {
            PJ_LOG (1, (THIS_FILE, "Error parsing rtcp attribute"));
            goto on_error;
          }

          if (strchr (ip, ':'))
            af = pj_AF_INET6 ();
          else
            af = pj_AF_INET ();

          pj_sockaddr_init (af, &holder->rem.def_addr[1], NULL, 0);
          tmp_addr = pj_str (ip);
          status = pj_sockaddr_set_str_addr (af, &holder->rem.def_addr[1],
              &tmp_addr);
          if (status != PJ_SUCCESS) {
            PJ_LOG (1, (THIS_FILE, "Invalid IP address"));
            goto on_error;
          }
          pj_sockaddr_set_port (&holder->rem.def_addr[1], (pj_uint16_t) port);

        } else if (strcmp (attr, "candidate") == 0) {
          char *sdpcand = attr + strlen (attr) + 1;
          int af, cnt;
          char foundation[32], transport[12], ipaddr[80], type[32];
          pj_str_t tmpaddr;
          int comp_id, prio, port;
          pj_ice_sess_cand *cand;
          pj_status_t status;

          cnt = sscanf (sdpcand, "%s %d %s %d %s %d typ %s",
              foundation, &comp_id, transport, &prio, ipaddr, &port, type);
          if (cnt != 7) {
            PJ_LOG (1, (THIS_FILE, "error: Invalid ICE candidate line"));
            goto on_error;
          }

          cand = &holder->rem.cand[holder->rem.cand_cnt];
          pj_bzero (cand, sizeof (*cand));

          if (strcmp (type, "host") == 0)
            cand->type = PJ_ICE_CAND_TYPE_HOST;
          else if (strcmp (type, "srflx") == 0)
            cand->type = PJ_ICE_CAND_TYPE_SRFLX;
          else if (strcmp (type, "relay") == 0)
            cand->type = PJ_ICE_CAND_TYPE_RELAYED;
          else {
            PJ_LOG (1, (THIS_FILE, "Error: invalid candidate type '%s'", type));
            goto on_error;
          }

          cand->comp_id = (pj_uint8_t) comp_id;
          pj_strdup2 (holder->pool, &cand->foundation, foundation);
          cand->prio = prio;

          if (strchr (ipaddr, ':'))
            af = pj_AF_INET6 ();
          else
            af = pj_AF_INET ();

          tmpaddr = pj_str (ipaddr);
          pj_sockaddr_init (af, &cand->addr, NULL, 0);
          status = pj_sockaddr_set_str_addr (af, &cand->addr, &tmpaddr);
          if (status != PJ_SUCCESS) {
            PJ_LOG (1, (THIS_FILE, "Error: invalid IP address '%s'", ipaddr));
            goto on_error;
          }

          pj_sockaddr_set_port (&cand->addr, (pj_uint16_t) port);

          ++holder->rem.cand_cnt;

          if (cand->comp_id > holder->rem.comp_cnt)
            holder->rem.comp_cnt = cand->comp_id;
        }
      }
        break;
    }

    free (tempStr);
  }

  printf ("holder->rem.cand_cnt = %d\n"
      "holder->rem.ufrag[0] = %d\n"
      "holder->rem.pwd[0] = %d\n"
      "holder->rem.comp_cnt = %d\n",
      holder->rem.cand_cnt,
      holder->rem.ufrag[0], holder->rem.pwd[0], holder->rem.comp_cnt);

  if (holder->rem.cand_cnt == 0 ||
      holder->rem.ufrag[0] == 0 ||
      holder->rem.pwd[0] == 0 || holder->rem.comp_cnt == 0) {
    PJ_LOG (1, (THIS_FILE, "Error: not enough info"));
    goto on_error;
  }

  if (comp0_port == 0 || comp0_addr[0] == '\0') {
    PJ_LOG (1, (THIS_FILE, "Error: default address for component 0 not found"));
    goto on_error;
  } else {
    int af;
    pj_str_t tmp_addr;
    pj_status_t status;

    if (strchr (comp0_addr, ':'))
      af = pj_AF_INET6 ();
    else
      af = pj_AF_INET ();

    pj_sockaddr_init (af, &holder->rem.def_addr[0], NULL, 0);
    tmp_addr = pj_str (comp0_addr);
    status = pj_sockaddr_set_str_addr (af, &holder->rem.def_addr[0], &tmp_addr);
    if (status != PJ_SUCCESS) {
      PJ_LOG (1, (THIS_FILE, "Invalid IP address in c= line"));
      goto on_error;
    }
    pj_sockaddr_set_port (&holder->rem.def_addr[0], (pj_uint16_t) comp0_port);
  }

  PJ_LOG (3, (THIS_FILE, "Done, %d remote candidate(s) added",
          holder->rem.cand_cnt));
  return;

on_error:
  reset_rem_info (holder);
}


/*
 * Start ICE negotiation! This function is invoked from the menu.
 */
static void
holder_start_nego (PjnathHolder * holder)
{
  printf ("holder_start_nego");
  pj_str_t rufrag, rpwd;
  pj_status_t status;

  if (holder->icest == NULL) {
    PJ_LOG (1, (THIS_FILE, "Error: No ICE instance, create it first"));
    return;
  }

  if (!pj_ice_strans_has_sess (holder->icest)) {
    PJ_LOG (1, (THIS_FILE, "Error: No ICE session, initialize first"));
    return;
  }

  if (holder->rem.cand_cnt == 0) {
    PJ_LOG (1, (THIS_FILE, "Error: No remote info, input remote info first"));
    return;
  }

  PJ_LOG (3, (THIS_FILE, "Starting ICE negotiation.."));

  status = pj_ice_strans_start_ice (holder->icest,
      pj_cstr (&rufrag, holder->rem.ufrag),
      pj_cstr (&rpwd, holder->rem.pwd), holder->rem.cand_cnt, holder->rem.cand);

  if (status != PJ_SUCCESS)
    holder_perror ("Error starting ICE", status);
  else
    PJ_LOG (3, (THIS_FILE, "ICE negotiation started"));
}


/*
 * Send application data to remote agent.
 */
static int
holder_send_data (unsigned comp_id, const char *data, PjnathHolder * holder)
{
  pj_status_t status;

  if (holder->icest == NULL) {
    PJ_LOG (1, (THIS_FILE, "Error: No ICE instance, create it first"));
    return 1;
  }

  if (!pj_ice_strans_has_sess (holder->icest)) {
    PJ_LOG (1, (THIS_FILE, "Error: No ICE session, initialize first"));
    return 1;
  }

  /*
     if (!pj_ice_strans_sess_is_complete(holder->icest)) {
     PJ_LOG(1,(THIS_FILE, "Error: ICE negotiation has not been started or is in progress"));
     return;
     }
   */

  if (comp_id < 1
      || comp_id > pj_ice_strans_get_running_comp_cnt (holder->icest)) {
    PJ_LOG (1, (THIS_FILE, "Error: invalid component ID"));
    return 1;
  }

  status = pj_ice_strans_sendto (holder->icest, comp_id, data, strlen (data),
      &holder->rem.def_addr[comp_id - 1],
      pj_sockaddr_get_len (&holder->rem.def_addr[comp_id - 1]));

  if (status != PJ_SUCCESS) {
    holder_perror ("Error sending data", status);
    return 1;
  } else {
    PJ_LOG (3, (THIS_FILE, "Data sent"));
    return 0;
  }
}

static void
get_local_stun_info (PjnathHolder * data)
{
  printf ("get_local_stun_info");
  holder_create_instance (data);

  /* Wait until all candidates gather done */
  while (pj_ice_strans_get_state (data->icest) != PJ_ICE_STRANS_STATE_READY) {
    printf ("%s",
        pj_ice_strans_state_name (pj_ice_strans_get_state (data->icest)));
    usleep (10000);
  }
  printf ("%s",
      pj_ice_strans_state_name (pj_ice_strans_get_state (data->icest)));

  holder_init_session ('o', data);
  holder_show_ice (data);
}

void
establish_stun_with_master (PjnathHolder * data, char *masterId)
{
  puts ("+++++++++++establish_stun_with_master");
  char *recBuf;
  char *sendBuf;
  char *destination;
  char *acception;
  pj_status_t status;

  recBuf = (char *) calloc (1024, sizeof (char));
  sendBuf = (char *) calloc (1024, sizeof (char));
  destination = (char *) calloc (1024, sizeof (char));
  acception = (char *) calloc (1024, sizeof (char));

  /* Initialize pjnath library */
  status = holder_init (data);
  //assert(status == PJ_SUCCESS);
  printf ("\n+++++++++++ip: %s, port = %d \n", data->ice_cfg.stun.server.ptr,
      data->ice_cfg.stun.port);

  /* Get local stun information */
  get_local_stun_info (data);

  /* Send local stun information  */
  sprintf (sendBuf, "<REQUESTCONN>"
      "<from>%s</from>"
      "<to>%s</to>"
      "<message>%s</message>"
      "</REQUESTCONN>", username, masterId, data->local_info);
  send (global_socket, sendBuf, strlen (sendBuf), 0);
  printf ("\n\n\n\n  username = %s \n", username);
  printf ("+++++++++++send: %s\n", sendBuf);

  /* Receive Rpi stun information */
  while (1) {
    if (recv (global_socket, recBuf, ICE_INFOR_SIZE, 0)) {
      printf ("+++++++++++receive: %s\n", recBuf);

      /* Destination is me? */
      parse_xml_node_content (recBuf, "to", destination);
      printf ("+++++++++++to: %s\n", destination);
      if (strcmp (destination, username))
        continue;

      /* Rpi accept connection? */
      parse_xml_node_content (recBuf, "accept", acception);
      printf ("+++++++++++accept: %s\n", acception);
      if (strcmp (acception, "true"))
        continue;

      /* Get STUN */
      data->remote_info = (char *) calloc (1024, sizeof (char));
      parse_xml_node_content (recBuf, "message", data->remote_info);
      break;
    } else {
      exit (EXIT_SUCCESS);
    }
  }

  /* Negotiation Rpi stun info */
  holder_input_remote (data->remote_info, data);
  holder_start_nego (data);

  free (recBuf);
  free (sendBuf);
  free (destination);
  free (acception);
}

void
establish_stun_with_client (PjnathHolder * data)
{
//      printf("establish_stun_with_client");
//      char *destination;
//      char *recBuf;
//      char *sendBuf;
//      pj_status_t status;
//    
//      androidClientId = (char *) calloc(100, sizeof(char));
//      destination = (char *) calloc(100, sizeof(char));
//      recBuf = (char *)calloc(1024, sizeof(char));
//      sendBuf = (char *)calloc(1024, sizeof(char));
//    
//      /* Receive android client stun information */
//      while(1) {
//              if(recv(global_socket, recBuf, ICE_INFOR_SIZE, 0)) {
//                      if(strstr(recBuf, "REQUESTCONN") != NULL) {
//                              printf("receive: %s", recBuf);
//                
//                              /* Destination is me? */
//                              parse_xml_node_content(recBuf, "to", destination);
//                              printf("to: %s", destination);
//                              if(strcmp(destination, username)) continue;
//                
//                              /* Get android client device id */
//                              parse_xml_node_content(recBuf, "from", androidClientId);
//                              printf("\nandroidClientId = %s\n", androidClientId);
//                
//                              /* Get STUN */
//                              data->remote_info = (char *) calloc (1024, sizeof(char));
//                              parse_xml_node_content(recBuf, "message", data->remote_info);
//                
//                              break;
//                      }
//              } else {
//                      exit(EXIT_SUCCESS);
//              }
//      }
//    
//      /* Initialize pjnath library */
//      status = holder_init(data);
//      assert(status == PJ_SUCCESS);
//    
//      /* Get local stun information */
//      get_local_stun_info(data);
//    
//      /* Send local stun information  */
//      sprintf(sendBuf, "<REQUESTCONNRESPOND>"
//            "<from>%s</from>"
//            "<to>%s</to>"
//            "<accept>true</accept>"
//            "<message>%s</message>"
//            "</REQUESTCONNRESPOND>",
//            username,
//            androidClientId,
//            data->local_info);
//      send(global_socket, sendBuf, strlen(sendBuf), 0);
//      printf("send: %s", sendBuf);
//    
//      /* Negotiation Rpi stun info */
//      holder_input_remote(data->remote_info, data);
//      holder_start_nego(data);
}
